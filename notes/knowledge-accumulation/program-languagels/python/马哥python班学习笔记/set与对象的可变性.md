# 集合set

set和dict类似，也是一组key的集合，但不存储value。key也具有不可重复性，key也是一个不可变的对象
集合的方法和操作。

方法:

1. len(s)：返回s中项目数
2. s.copy()：制作s的一个副本
3. s.difference(t)：求差集，返回所有在s中，但不在t中的项目
4. s.intersection(t)：求交集，返回所有在s和t中的项目
5. s.isdisjoint(t)：如果s和t没有相同项，则返回True
6. s.issubsent(t)：如果s是t的一个子集，则返回True
7. s.issuperset(t)：如果s是t的一个超集，则返回True
8. s.symmetric_difference(t)：求对称差集，返回所有在s或t中，但又不同时在这两个集合中的项
9. s.union(t)：求并集，返回所有在s或t中的项

操作：

```
s | t       s和t的并集
s & t       s和t的交集
s - t       求差集
s ^ t       求对称差集
```


在定义一个set时比较特别，它需要一个list来作为其输入，如：

```python
>>> s = set([10,20,30])
>>> s
set([10, 20, 30])
```

需要注意的是，在定义set时需要用List来传入数据，在输出时set[10,20,30])只是表示这个set中有10,20,30这三个元素，在输出结果中"[]"并不表示输出的是一个List。

在set中key与dict中的key一样具有唯一性，如果定义了相同的key，那s    et将直接过虑掉重复的key，而只显示一个：

```python
>>> s = set([10,20,30,10,20])
>>> s
set([10, 20, 30])
```

向set中增加元素用"add()"方法：

```python
>>> s = set([10,20,30])
>>> s
set([10, 20, 30])
>>> s.add(30)
>>> s
set([10, 20, 30])
>>> s.add(40)
>>> s
set([40, 10, 20, 30])
>>> s.add(50)
>>> s
set([40, 10, 20, 50, 30])
>>> s.add(60)
>>> s
set([40, 10, 50, 20, 60, 30])
>>> s.add(100)
>>> s
set([100, 40, 10, 50, 20, 60, 30])
```

通过上边的例子发现在用add()方法向set中增加数据时，发现如果增加的是原有set中存在的数据，可以增加，但对set没有任何效果；还发现set的数据的排列与增加数据的大小与顺序是没有关系的，所以可以把set看成是一种无序和无重复元素的集合。

从set中删除数据用remove()方法：

```py
>>> s.add('zhaochj')
>>> s
set([100, 40, 10, 'zhaochj', 50, 20, 60, 30])
>>> s.remove(100)
>>> s
set([40, 10, 'zhaochj', 50, 20, 60, 30])
#set中能存放的元素类型也可以是字符串
```

既然set是一个无序数据和无重复元素的集合，那可以对两个set做交集、并集等这样的操作：

```py
>>> s1 = set([10,20,30])
>>> s2 = set([20,30,40])
>>> s1 & s2
set([20, 30])
>>> s1 | s2
set([20, 40, 10, 30])
```

最后来看一下dict与set的区别：set与dict的原理都一样，key都是不可变对象，唯一的区别就是set没有存储value，而dict既存储了key，也存储了value。

# 不可变对象

从上面讲的可知，字符串(str)是一种不变对象，而list是可变对象，对于可变对象，我们可以对它进行操作，使其发生改变：

```py
>>> L = [30,20,10]
>>> L
[30, 20, 10]
>>> id(L)
140130202951480
>>> L.sort()
>>> L
[10, 20, 30]
>>> id(L)
140130202951480
#上边对一个list，采用sort()方法对其操作后，list中的元素排序顺序发生了改变，对象就发生改变了，值得注意的是list中元素发生改变了，但list在内存中的存储位置还是没有发生变化的。
```

而对于不变对象，比如str类型，一旦定义那就不会发生改变：

```py
>>> str1 = 'a'
>>> id(str1)
140130204091656
>>> str1
'a'
>>> str1.replace('a','A')
'A'
>>> str1
'a'
>>> id(str1)
140130204091656
>>> str2 = str1.replace('a','A')
>>> str2
'A'
>>> id(str2)
140130203137208
```

从上边的例子中可看出对于变量str1，我们先赋予它一个字符串类型的值，再用replace()方法把值从小写字母a替换成了A，但当再次取得str1变量的值时发现值还是a，并不是A，而且在内在空间的存储位置依然是“140130204091656”，而当用str2变量来取得替换str1后的值后，str2的值是A，在内在存储位置已发生了改变，变成了“140130203137208”。这说明什么问题？对于字符串，虽然对replace()方法对其进行替换操作，从输出内容的表面上看其值的确变成了“A”，但真实的过程是python在调用replace()方法后创建了一个新的字符串“A”返回，而原来存储“a”字符串的内在空间依然存在。
